---
title: "P300 Speller with patient with ALS"
subtitle: "Progetto MOBD 2018/19"
author: "Conidi Andrea, Falvo Simone"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r include=FALSE}
#load("env.RData")
```
```{r include=FALSE}
library("dplyr")
library("LiblineaR")
library("e1071")
library(CORElearn)
library("R.utils")
library(Bolstad2)
library(DescTools)
source("constants.R")
source("data_split.R")
source("utils.R")
source("new_c_data.R")
source("normalization.R")
source("cross_validation.R")
source("cross_validation_param.R")
source("choosing_cross_validation.R")
source("test_accuracy.R")
source("decision_function.R")
source("feature_selection.R")
source("data_augmentation.R")
source("data_understanding.R")


#Caricamento Dati
dfx_training <- read.table("X.txt", header = FALSE)
dfc_training <- read.table("C.txt", header = FALSE)
dfy_training <- read.table("Y.txt", header = FALSE)
#dfx_test <- read.table("X_test.txt", header = FALSE)
#dfc_test <- read.table("C_test.txt", header = FALSE)
#dfy_test <- read.table("Y_test.txt", header = FALSE)

#Applicazione delle etichette sulle colonne del df
#dfx_training <- feature_smooth(dfx_training)
dfx_training <- apply_labels(dfx_training)
colnames(dfc_training) <- "c"
colnames(dfy_training) <- "label"

#set del seme per la ripetibilità dell'esperimento
set.seed(123)

#eliminazione canali
#fourth_ccol <- c(((4-1) * SAMPLE_POINTS + 1):(4 * SAMPLE_POINTS))
#seventh_ccol <- c(((7-1) * sample_pointS + 1):(7 * SAMPLE_POINTS))
#dfx <- dfx_training[, -c(fourth_ccol, seventh_ccol)]

# bind delle istanze con le corrispondenti etichette
dfxy <- cbind(dfx_training, dfy_training)
dfcxy <- cbind(dfc_training, dfx_training, dfy_training)



#split dei dati in training e test: $train e $test 
splitted_data <- data_split(dfcxy)

training_set <- splitted_data$train
test_set <- splitted_data$test


#data augmentation
#augmented_train <- rbind(dfcxy, generate_data(dfcxy, 0.3, put_noise))
#augmented_train <- rbind(dfcxy, generate_data(dfcxy, 0.3, right_shift, shift_size = floor(SAMPLE_POINTS * 0.1)))
augmented_train <- rbind(training_set, 
                         generate_data(training_set, 0.3, meanchar_gen, n=2))
#augmented_train <- training_set


#feature selection
p300 <- extract_P300(get_xydf(augmented_train))
featured_train <- feature_selection(augmented_train, p300)
featured_test <- feature_selection(test_set, p300)


#normalizzazione
scaled_data = normalize(featured_train, featured_test)


#training
model <- LiblineaR(data = get_xdf(scaled_data$train),
                   target = get_ydf(scaled_data$train),
                   type = 7, cost = 0.01, bias = TRUE, verbose = FALSE)

#---------crossvalidazione-------------
#scegliamo il valore migliore di loss e c
#outcome<- choosing_cross_validation(scaled_data$train)
#rifacciamo cross_validation sul train
cv_results <- cross_validation(scaled_data$train, 
                               classifier = LiblineaR, 
                               type = 7, cost = 0.01, bias = TRUE, verbose = FALSE)
print(cv_results)


#test
accuracy <- test_accuracy(model, scaled_data$test)
printf("Caratteri predetti correttamente: %.2f %%", accuracy * 100)

```



# Introduzione

Lo scopo del progetto è quello di predire correttamente i caratteri corrispondenti a sequenze di stimolazioni provenienti da un'interfaccia BCI.

Il lavoro svolto è stato quello di utilizzare tecniche di classificazione binaria per distinguere le istanze *target* da quelle *non target*. In particolare è stato utilizzato un classificatore di tipo SVM lineare con l'ausilio di tecniche di data augmentation e feature selection, inoltre è stata modificata la funzione di decisione in modo che, in corrispondenza di ogni iterazione di stimolazioni, vengano selezionate come target una sola riga ed una sola colonna.

Il classificatore è stato addestrato su una porzione del dataset fornito, l'altra porzione è stata utilizzata come test ed i risultati finali hanno mostrato...



# Data Understanding

```{r}
visualize_data(dfxy)
```



# Data Splitting

Per addestrare e testare il modello, il dataset è stato suddiviso in training set e test set con una proporzione 70-30.

Prima di effettuare lo split, è stata applicata una permutazione a blocchi di 120 righe, in modo da mantenere la sequenzialità delle iterazioni per ogni carattere, che viene poi sfruttata per determinare gli indici di riga e colonna corrispondenti al carattere target.



# Data Augmentation

Per aumentare l'accuratezza del modello, sono stati introdotti dati fittizi generati a partire da un sottoinsieme del training set.

Inizialmente si è provato a generare dati aggiungendo semplicemente del rumore bianco oppure effettuando piccole traslazioni temporali dei valori di tensione (in modo da rendere più "robusto" il modello a eventuali errori o ritardi di misurazione), ma ciò non ha prodotto buoni risultati in cross-validazione. La tecnica risultata efficace è stata quella di generare nuovi caratteri aventi come valori di misurazione la media delle istanze appartenenti alla stessa classe di due caratteri diversi.

Sperimentalmente si ottengono risultati migliori generando un numero di caratteri pari al 30\% di quelli presenti del dataset, ed ognuno di essi viene generato "mediando" il numero minimo di caratteri, perché all'aumentare di tale quantità si ottengono caratteri con meno rumore che differiscono troppo dal dataset originale.

```{r}
augmented_train <- rbind(training_set, 
                         generate_data(training_set, 0.3, meanchar_gen, n=2))
```



# Feature Selection

Le feature implementate sono state prese dall'articolo *A new approach for EEG feature extraction in P300-based lie detection*.
Tra le feature sugerite dall'articolo si è deciso di provare a utilizzare:

* Area Positiva
* Area Negativa
* Area assoluta : somma dei moduli delle due aree precedenti
* Crossing Zero: numero di volte in cui il segnale passa per zero
* Potenza del segnale: cacolata come potenza=x
* Valore di Picco Picco
* Time Window: intervallo di tempo tra il picco positivo e negativo

Alcune delle feature sono invece state implementate analizzando i dati nella fase di data understanding:

* Rising Time: conta gli istanti temporali in cui il segnale è crescente
* Correlazione P300: calcola dal training set il segnale medio corrispondente alla P300 e costruisce la          matrice di correlazione con tutte le misurazioni.
* C_bin: matrice binaria calcolata a partire dal file C.txt, dove l'elemento c_bin[i,j]=1 se c[i]=j

La scelta delle features è stata fatta valutando le varie combinazioni in cross validation. Il set migliore è stato quello composto da: Area Assoluta,P300 e Crossing Zero.



# Normalizzazione

A seguito dell'introduzione di nuove feature i dati vengono normalizzati applicando la seguente trasformazione su ogni colonna dei dataset:

\begin{displaymath}
Z_{train} = \frac{X_{train} - \overline{X}_{train}}{\sigma_{train}}
\qquad \quad
Z_{test} = \frac{X_{test} - \overline{X}_{train}}{\sigma_{train}}
\end{displaymath}

Dove $\overline{X}$ e $\sigma$ sono rispettivamente media campionaria e deviazione standard dei dati delle istanze relativi ad una feature.

I dati di test vengono scalati utilizzando media campionaria e deviazione standard dei dati di training, essendo quest'ultimi un campione più numeroso della stessa distribuzione.

## Relief

Le features selezione sono state valutate tramite la Relief. Di seguito l'istogramma contenente le valutazioni degli attributi:
***********************inserire grafico *******************************



# Training

## Funzione di decisione

Funzione basata sul massimo invece che sul segno. Partendo dai decision values ottenuti dalla predict di liblinear si seleziona un blocco di 120 righe corrispondente a un carattere e ogni 12 righe vengono estratti gli indici riga e colonna  contenententi il valore massimo.
Il risultato per ogni carattere sarà una matrice di indici riga/colonna  target, con un numero di righe pari al numero di iterazioni. A tale matrice viene applicata la moda per colonne ottenendo  la combinazione più frequente. Dopodiché si genera il nuovo blocco di predizioni impostando come target le istanze corrispondenti agli indici selezionati. 



# Cross-Validazione

Tutti i parametri del progetto sono stati calibrati sulla base dei risultati ottenuti in fase di cross-validazione.

In questa fase è stata applicata la tecnica *K-fold* con un valore di k pari a 10.
```{r}
cv_results <- cross_validation(scaled_data$train, 
                               classifier = LiblineaR, 
                               type = 7, cost = 0.01, bias = TRUE, verbose = FALSE)
print(cv_results)
```



# Risultati e Conclusioni

Infine il modello viene valutato sul test set, fornendo un'indicazione della percentuale di caratteri correttamenti classificati.

I risultati mostrano sul test un'accuretezza pari al 100%%, tale risultato è stato ottenuto con un seme iniziale pari a 123.

```{r}
accuracy <- test_accuracy(model, scaled_data$test)
#printf("Caratteri predetti correttamente: %.2f %%", accuracy * 100)
```



# How To

Per addestrare e testare il modello con un nuovo Test set
Nel file main.R inserire nella sequente sezione di codice i nomi dei file.
```{r}
#dfx_test <- read.table("X_test.txt", header = FALSE)
#dfc_test <- read.table("C_test.txt", header = FALSE)
#dfy_test <- read.table("Y_test.txt", header = FALSE)
```